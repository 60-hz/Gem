////////////////////////////////////////////////////////
//
// GEM - Graphics Environment for Multimedia
//
// zmoelnig@iem.at
//
// Implementation file
//
//    Copyright (c) 2015 IOhannes m zmölnig. forum::für::umläute. IEM. zmoelnig@iem.at
//    For information on usage and redistribution, and for a DISCLAIMER OF ALL
//    WARRANTIES, see the file, "GEM.LICENSE.TERMS" in this distribution.
//
/////////////////////////////////////////////////////////
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include "videoDECKLINK.h"
#include "plugins/PluginFactory.h"
#include "Gem/Exception.h"


/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
class DeckLinkCaptureDelegate : public IDeckLinkInputCallback
{
private:
  ULONG m_refCount;
  pthread_mutex_t m_mutex;

  unsigned long m_frameCount;
  BMDVideoInputFlags m_cfg_inputFlags;
  BMDPixelFormat m_cfg_pixelFormat;
  IDeckLinkInput*m_deckLinkInput;

public:
  DeckLinkCaptureDelegate(IDeckLinkInput*dli)
    : IDeckLinkInputCallback()
    , m_refCount(0)
    , m_frameCount(0)
    , m_cfg_inputFlags(bmdVideoInputFlagDefault)
    , m_cfg_pixelFormat(bmdFormat8BitYUV)
    , m_deckLinkInput(dli)
  {
    pthread_mutex_init(&m_mutex, NULL);
    m_deckLinkInput->SetCallback(this);
    //result = m_deckLinkInput->EnableVideoInput(displayMode->GetDisplayMode(), m_cfg_pixelFormat, m_cfg_inputFlags);
    //m_deckLinkInput->DisableAudioInput();

  }

  ~DeckLinkCaptureDelegate()
  {
    pthread_mutex_destroy(&m_mutex);
  }
  virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppv) { return E_NOINTERFACE; }
  virtual ULONG STDMETHODCALLTYPE AddRef(void)
  {
    pthread_mutex_lock(&m_mutex);
    m_refCount++;
    pthread_mutex_unlock(&m_mutex);

    return (ULONG)m_refCount;
  }
  virtual ULONG STDMETHODCALLTYPE  Release(void) {
    pthread_mutex_lock(&m_mutex);
    m_refCount--;
    pthread_mutex_unlock(&m_mutex);

    if (m_refCount == 0) {
      delete this;
      return 0;
    }

    return (ULONG)m_refCount;
  }
  virtual HRESULT STDMETHODCALLTYPE VideoInputFrameArrived(IDeckLinkVideoInputFrame*videoFrame, IDeckLinkAudioInputPacket*audioFrame)
  {
    IDeckLinkVideoFrame*rightEyeFrame = NULL;
    IDeckLinkVideoFrame3DExtensions*	threeDExtensions = NULL;
    void*frameBytes;
    void*audioFrameBytes;

    // Handle Video Frame
    if (videoFrame) {
      // If 3D mode is enabled we retreive the 3D extensions interface which gives.
      // us access to the right eye frame by calling GetFrameForRightEye() .
      if ( (videoFrame->QueryInterface(IID_IDeckLinkVideoFrame3DExtensions, (void **) &threeDExtensions) != S_OK) ||
	   (threeDExtensions->GetFrameForRightEye(&rightEyeFrame) != S_OK)) {
	rightEyeFrame = NULL;
      }

      if (threeDExtensions)
	threeDExtensions->Release();

      if (videoFrame->GetFlags() & bmdFrameHasNoInputSource) {
	//printf("Frame received (#%lu) - No input signal detected\n", m_frameCount);
      } else {
#if 0
	if (g_videoOutputFile != -1) {
	    videoFrame->GetBytes(&frameBytes);
	    write(g_videoOutputFile, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());

	    if (rightEyeFrame) {
	      rightEyeFrame->GetBytes(&frameBytes);
	      write(g_videoOutputFile, frameBytes, videoFrame->GetRowBytes() * videoFrame->GetHeight());
	    }
	  }
#endif
	}

      if (rightEyeFrame)
	rightEyeFrame->Release();

      m_frameCount++;
    }

    return S_OK;
  }

  virtual HRESULT STDMETHODCALLTYPE
  VideoInputFormatChanged(BMDVideoInputFormatChangedEvents events,
			  IDeckLinkDisplayMode*mode,
			  BMDDetectedVideoInputFormatFlags)
  {
    // This only gets called if bmdVideoInputEnableFormatDetection was set
    // when enabling video input
    HRESULT	result;
    char*	displayModeName = NULL;

    if (!(events & bmdVideoInputDisplayModeChanged))
      return S_OK;

    mode->GetName((const char**)&displayModeName);
    //printf("Video format changed to %s\n", displayModeName);

    if (displayModeName)
      free(displayModeName);

    if (m_deckLinkInput) {
      m_deckLinkInput->StopStreams();

      result = m_deckLinkInput->EnableVideoInput(mode->GetDisplayMode(), m_cfg_pixelFormat, m_cfg_inputFlags);
      if (result != S_OK) {
	//fprintf(stderr, "Failed to switch video mode\n");
	goto bail;
      }

      m_deckLinkInput->StartStreams();
    }

  bail:
    return S_OK;
  }
};
/*
** END of Blackmagic licensed code
*/


namespace {
  IDeckLinkDisplayMode*getDisplayMode(IDeckLinkInput*dli, const std::string&formatname, int formatnum) {
    IDeckLinkDisplayModeIterator*dmi = NULL;
    IDeckLinkDisplayMode*displayMode = NULL;
    const std::string name=(("auto"==formatname) || ("automatic" == formatname))?"":formatname;
    int count=formatnum;
    if(S_OK == dli->GetDisplayModeIterator(&dmi)) {
      while(S_OK == dmi->Next(&displayMode)) {
	if (formatnum<0 && name.empty()) {
	  // we don't care for the format; accept the first one
	  break;
	}

	// if we have set the format name, check that
	if(!name.empty()) {
	  char*dmn = NULL;
	  if (S_OK == displayMode->GetName((const char**)dmn)) {
	    bool found=(name == dmn);
	    free(dmn);
	    if(found)break;
	  }
	}
	// else check the format index
	if(formatnum>=0 && 0 == count)
	  break;
	--count;

	displayMode->Release();
	displayMode=NULL;
      }
      dmi->Release();
    }
    return displayMode;
  }
};




using namespace gem::plugins;

REGISTER_VIDEOFACTORY("decklink", videoDECKLINK);

videoDECKLINK::videoDECKLINK(void)
  : m_name(std::string("decklink"))
{
  m_deckLinkIterator = CreateDeckLinkIteratorInstance();
  if(m_deckLinkIterator) {
    throw(GemException("DeckLink: unable to initialize Framework"));
  }

  m_pixBlock.image.xsize = 64;
  m_pixBlock.image.ysize = 64;
  m_pixBlock.image.setCsizeByFormat(GL_RGBA);
  m_pixBlock.image.reallocate();
}

videoDECKLINK::~videoDECKLINK(void) {
  close();
}

void videoDECKLINK::close(void) {
}


bool videoDECKLINK::open(gem::Properties&props) {
  if(m_devname.empty())return false;
  setProperties(props);
  return false;
}

pixBlock*videoDECKLINK::getFrame(void) {
  return 0;
  return &m_pixBlock;
}

std::vector<std::string>videoDECKLINK::enumerate(void) {
  std::vector<std::string>result;
  //result.push_back("decklink");
  return result;
}

bool videoDECKLINK::setDevice(int ID) {
  m_devname.clear();
  return false;
}
bool videoDECKLINK::setDevice(std::string device) {
  m_devname.clear();
  const std::string prefix="decklink://";
  if (!device.compare(0, prefix.size(), prefix)) {
    m_devname=device.substr(prefix.size());
    return true;
  }
  return false;
}
bool videoDECKLINK::enumProperties(gem::Properties&readable,
			       gem::Properties&writeable) {
  std::string dummy_s;
  int dummy_i=0;
  readable.clear();
  writeable.clear();

  readable.set("width", m_pixBlock.image.xsize);
  readable.set("height", m_pixBlock.image.ysize);

  //writeable.set("mouse.mask", dummy_i);

  return true;
}
void videoDECKLINK::setProperties(gem::Properties&props) {
  m_props=props;

  double num;
  std::string s;

}
void videoDECKLINK::getProperties(gem::Properties&props) {
  std::vector<std::string>keys=props.keys();
  unsigned int i;
  for(i=0; i<keys.size(); i++) {
    if("width"==keys[i]) {
      props.set(keys[i], m_pixBlock.image.xsize);
    }
    if("height"==keys[i]) {
      props.set(keys[i], m_pixBlock.image.ysize);
    }
  }
}

std::vector<std::string>videoDECKLINK::dialogs(void) {
  std::vector<std::string>result;
  return result;
}
bool videoDECKLINK::provides(const std::string name) {
  return (name==m_name);
}
std::vector<std::string>videoDECKLINK::provides(void) {
  std::vector<std::string>result;
  result.push_back(m_name);
  return result;
}
const std::string videoDECKLINK::getName(void) {
  return m_name;
}


#ifdef MUST_DLOPEN_DECKLINKAPI
# include <DeckLinkAPIDispatch.cpp>
#endif
